# -*- coding: utf-8 -*-
"""Full Code .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18lRusT7pRgG2B95eN5oRr05imiq547aQ
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
import warnings
warnings.filterwarnings('ignore')
from sklearn.model_selection import StratifiedKFold
kFold = StratifiedKFold(n_splits=5)
from sklearn.model_selection import GridSearchCV
from sklearn.preprocessing import StandardScaler
from  sklearn.metrics  import  accuracy_score , precision_score , recall_score,confusion_matrix,classification_report

"""# Data Exploration and Cleaning"""

df = pd.read_csv("/content/Real Estate Data V21.csv")

display(df)

df.info()

df.describe()

df.isnull().sum().sum()

import re

def clean_price(price_str):
    price_str = price_str.replace('‚Çπ', '').replace(',', '').strip()
    match = re.match(r'([\d\.]+)\s*([A-Za-z]+)', price_str)
    if match:
        value = float(match.group(1))
        unit = match.group(2).lower()
        if unit == 'cr':
            return value * 1e7
        elif unit == 'l':
            return value * 1e5
    else:
        try:
            return float(price_str)
        except:
            return None

df['Price_Cleaned'] = df['Price'].apply(clean_price)



display(df)

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
df['Location_Encoded'] = le.fit_transform(df['Location'])
df['Balcony_Encoded'] = le.fit_transform(df['Balcony'])



"""# Data Visualization

"""

df['Area_per_Bath'] = df['Total_Area'] / df['Baths']

X = df[['Total_Area', 'Baths', 'Price_per_SQFT', 'Location_Encoded', 'Balcony_Encoded', 'Area_per_Bath']]
y = df['Price_Cleaned']

df['Price_Log'] = np.log1p(df['Price_Cleaned'])

plt.figure(figsize=(10,6))
sns.histplot(df['Price_Log'], bins=50, kde=True)
plt.title("Log-Transformed Price Distribution")
plt.xlabel("Log(Price + 1)")
plt.show()

df['Area_Log'] = np.log1p(df['Total_Area'])

plt.figure(figsize=(10,6))
sns.scatterplot(x='Area_Log', y='Price_Log', data=df)
plt.title("Log Price vs Log Total Area")
plt.xlabel("Log(Total Area + 1)")
plt.ylabel("Log(Price + 1)")
plt.show()

plt.figure(figsize=(10,6))
sns.boxplot(x='Baths', y='Price_Log', data=df)
plt.title("Log Price by Number of Bathrooms")
plt.xlabel("Number of Bathrooms")
plt.ylabel("Log(Price + 1)")
plt.show()

plt.figure(figsize=(8, 6))
sns.heatmap(
    df[['Total_Area', 'Baths', 'Price_per_SQFT', 'Area_per_Bath', 'Price_Cleaned']].corr(),
    annot=True,
    cmap='coolwarm',
    fmt='.2f'
)
plt.title("Correlation Heatmap")
plt.show()

"""# Model Building and Hyperparameter Tuning"""

from sklearn.linear_model import LinearRegression, Ridge, Lasso, ElasticNet
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Drop rows with NaN in 'Price_Cleaned'
df.dropna(subset=['Price_Cleaned'], inplace=True)

X = df[["Total_Area","Baths","Price_per_SQFT",
        "Location_Encoded","Balcony_Encoded","Area_per_Bath"]]
y = df["Price_Cleaned"]

#  TRAIN / TEST SPLIT  +  SCALING
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=.2,random_state=42)
scaler = StandardScaler()
X_train_s, X_test_s = scaler.fit_transform(X_train), scaler.transform(X_test)

#  BASELINE OLS
baseline = LinearRegression().fit(X_train_s, y_train)
def metrics(y,t): return {"MAE":mean_absolute_error(y,t),
                          "RMSE":np.sqrt(mean_squared_error(y,t)),
                          "R2":r2_score(y,t)}
results = {"LinearRegression (OLS)" : metrics(y_test, baseline.predict(X_test_s))}

#  GRID‚ÄëSEARCH TUNING
tune_cfg = [
    ("Ridge",     Ridge(),     {"alpha":[0.01,0.1,1,10,50,100]}),
    ("Lasso",     Lasso(max_iter=10000), {"alpha":[1e-4,1e-3,1e-2,0.1,1,10]}),
    ("ElasticNet",ElasticNet(max_iter=10000),
                                {"alpha":[1e-4,1e-3,1e-2,0.1,1],
                                 "l1_ratio":[.1,.3,.5,.7,.9]})
]
for name, est, grid in tune_cfg:
    gcv = GridSearchCV(est, grid, cv=5,
                       scoring="neg_mean_absolute_error")
    gcv.fit(X_train_s, y_train)
    best = gcv.best_estimator_
    results[f"{name} (tuned)"] = metrics(y_test,best.predict(X_test_s))
    print(f"{name} best params ‚Üí {gcv.best_params_}")

# COMPARE
res_df = pd.DataFrame(results).T.round(2)
print("\nModel comparison:")
print(res_df)

# BAR PLOT
res_df[["MAE","RMSE"]].plot(kind="bar", figsize=(9,5), title="Linear‚Äëfamily Models\nMAE & RMSE")
plt.ylabel("Error"); plt.tight_layout(); plt.show()

#PolynomialRegression

from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import make_pipeline

df_cleaned = df.dropna(subset=['Price_Cleaned']).copy()

X_poly = df_cleaned[['Total_Area']]
y_poly = df_cleaned['Price_Cleaned']

# Split data into training and testing sets
X_train_poly, X_test_poly, y_train_poly, y_test_poly = train_test_split(X_poly, y_poly, test_size=0.2, random_state=42)

# Create a pipeline for polynomial regression
# Degree of polynomial can be adjusted
poly_model = make_pipeline(PolynomialFeatures(degree=2), LinearRegression())

# Train the model
poly_model.fit(X_train_poly, y_train_poly)

# Make predictions
y_pred_poly = poly_model.predict(X_test_poly)

# Evaluate the model (using metrics like R-squared or Mean Squared Error)
from sklearn.metrics import r2_score, mean_squared_error
print(f"R-squared: {r2_score(y_test_poly, y_pred_poly)}")
print(f"Mean Squared Error: {mean_squared_error(y_test_poly, y_pred_poly)}")

# Optional: Visualize the polynomial fit
plt.figure(figsize=(10, 6))
plt.scatter(X_test_poly, y_test_poly, color='blue', label='Actual')
# To plot the polynomial curve, we need to sort the test data
sort_axis = np.argsort(X_test_poly.values.flatten())
plt.plot(X_test_poly.values[sort_axis], y_pred_poly[sort_axis], color='red', label='Polynomial Fit')
plt.title("Polynomial Regression Fit")
plt.xlabel("Total Area")
plt.ylabel("Price Cleaned")
plt.legend()
plt.show()

#DecisionTreeRegressor

from sklearn.tree import DecisionTreeRegressor

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a Decision Tree Regressor model
dt_model = DecisionTreeRegressor(random_state=42)

# Train the model
dt_model.fit(X_train, y_train)

# Predict on the test data
y_pred = dt_model.predict(X_test)

# Evaluate the model (optional, but good practice for regression)
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

rmse = np.sqrt(mean_squared_error(y_test, y_pred))
r2 = r2_score(y_test, y_pred)

print(f"Decision Tree Regressor - RMSE: {rmse:.2f}")
print(f"Decision Tree Regressor - R-squared: {r2:.2f}")

# You can also visualize the decision tree if needed (requires graphviz)
# !pip install graphviz
# from sklearn.tree import export_graphviz
# import graphviz

# dot_data = export_graphviz(dt_model, out_file=None,
#                            feature_names=X.columns,
#                            filled=True, rounded=True,
#                            special_characters=True)
# graph = graphviz.Source(dot_data)
# graph.render("decision_tree") # This will save a PDF file

# To display the tree within the notebook:
# graphviz.Source(dot_data)

#LogisticRegression



import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix

# binary target based on whether the price is above the median.
df['Price_Above_Median'] = (df['Price_Cleaned'] > df['Price_Cleaned'].median()).astype(int)

# Define features (X) and the new binary target (y)
X = df[['Total_Area', 'Baths', 'Price_per_SQFT', 'Location_Encoded', 'Balcony_Encoded', 'Area_per_Bath']]
y = df['Price_Above_Median']


# Replace inf values with NaN
X.replace([np.inf, -np.inf], np.nan, inplace=True)
X.dropna(inplace=True)
y = y[X.index] # Align the target variable with the cleaned features

# train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Scale the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Initialize and train the Logistic Regression model
log_reg = LogisticRegression(solver='liblinear', random_state=42) # Using liblinear solver for smaller datasets
log_reg.fit(X_train_scaled, y_train)

# Make predictions on the test set
y_pred = log_reg.predict(X_test_scaled)

# Evaluate the model
print("Logistic Regression Model Evaluation:")
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("\nClassification Report:\n", classification_report(y_test, y_pred))

import matplotlib.pyplot as plt
# Visualize the correlation matrix
plt.figure(figsize=(12, 8))
sns.heatmap(df[['Total_Area', 'Baths', 'Price_per_SQFT', 'Location_Encoded', 'Balcony_Encoded', 'Area_per_Bath', 'Price_Cleaned', 'Price_Above_Median']].corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix of Selected Features and Target Variables")
plt.show()

#Deployment Code

import joblib

# Assuming best model
joblib.dump(best, "price_model.pkl")
joblib.dump(scaler, "scaler.pkl")
joblib.dump(le, "location_encoder.pkl")     # for Location_Encoded
joblib.dump(le, "balcony_encoder.pkl")      # for Balcony_Encoded

le_loc = LabelEncoder()
le_bal = LabelEncoder()

!pip install streamlit

import streamlit as st
import numpy as np
import joblib


model  = joblib.load("price_model.pkl")
scaler = joblib.load("scaler.pkl")
le_bal = joblib.load("balcony_encoder.pkl")

st.title(" House Rent Price Predictor")

area            = st.number_input("Total Area (sqft)", 100, 20000, 1000)
baths           = st.selectbox("Number of Bathrooms", [1, 2, 3, 4, 5, 6])
price_per_sqft  = st.number_input("Price per Sqft", 100.0, 100000.0, 5000.0)
balcony         = st.selectbox("Balcony", le_bal.classes_)

if st.button("Predict Rent Price"):
    bal_encoded   = le_bal.transform([balcony])[0]
    area_per_bath = area / (baths + 1)

    features      = np.array([[area, baths, price_per_sqft,
                               0, bal_encoded, area_per_bath]])  # 0 in place of location
    features_std  = scaler.transform(features)
    price_pred    = model.predict(features_std)[0]

    st.success(f"üè∑Ô∏è Predicted Rent Price: ‚Çπ‚ÄØ{price_pred:,.0f}")